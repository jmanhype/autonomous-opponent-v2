defmodule AutonomousOpponentV2Web.MetricsController do
  @moduledoc """
  Controller for exposing metrics in Prometheus format.
  This endpoint can be scraped by Prometheus/Grafana for monitoring.
  
  Enhanced with VSM Multi-Mind recommendations:
  - Metric type annotations for Prometheus compliance
  - CORS headers for cross-origin scraping
  - Cardinality tracking to prevent explosion
  - Meta-metrics about the metrics system itself
  """
  use AutonomousOpponentV2Web, :controller

  # Maximum allowed metric cardinality to prevent memory explosion
  @max_metric_cardinality 10_000

  def index(conn, _params) do
    prometheus_text =
      case Process.whereis(AutonomousOpponentV2Core.Core.Metrics) do
        nil ->
          # Return empty metrics if metrics system not running
          "# No metrics available - metrics system not running\n"
        _pid ->
          try do
            # Get raw metrics
            metrics_text = AutonomousOpponentV2Core.Core.Metrics.prometheus_format(AutonomousOpponentV2Core.Core.Metrics)
            
            # Add metric type annotations and meta-metrics
            enhance_prometheus_output(metrics_text)
          rescue
            error ->
              # Log the actual error for debugging
              require Logger
              Logger.error("Failed to retrieve metrics: #{inspect(error)}")
              "# Error retrieving metrics\n"
          end
      end

    # Apply CORS headers based on configuration
    conn = if Application.get_env(:autonomous_opponent_web, :metrics_endpoint_cors_enabled, true) do
      cors_origin = Application.get_env(:autonomous_opponent_web, :metrics_endpoint_cors_origin, "*")
      put_resp_header(conn, "access-control-allow-origin", cors_origin)
    else
      conn
    end

    conn
    |> put_resp_content_type("text/plain; version=0.0.4")
    |> send_resp(200, prometheus_text)
  end

  # Enhance Prometheus output with type annotations and meta-metrics
  defp enhance_prometheus_output(metrics_text) do
    cardinality = count_metric_cardinality(metrics_text)
    
    # Check cardinality limit
    if cardinality > @max_metric_cardinality do
      require Logger
      Logger.error("Metric cardinality (#{cardinality}) exceeds limit (#{@max_metric_cardinality})")
      
      # Return warning with truncated metrics
      warning = """
      # WARNING: Metric cardinality (#{cardinality}) exceeds limit (#{@max_metric_cardinality})
      # Metrics have been truncated to prevent memory exhaustion
      # Generated at: #{DateTime.utc_now() |> DateTime.to_iso8601()}
      
      """
      
      # Truncate metrics to stay under limit
      truncated_metrics = truncate_metrics_safely(metrics_text, @max_metric_cardinality)
      warning <> truncated_metrics
    else
      # Add header with metadata
      header = """
      # Autonomous Opponent VSM Metrics
      # Generated at: #{DateTime.utc_now() |> DateTime.to_iso8601()}
      # Cardinality: #{cardinality} metrics
      
      """
      
      # Add type annotations for known metrics
      type_annotations = """
      # HELP vsm_variety_absorbed The amount of variety absorbed by each subsystem
      # TYPE vsm_variety_absorbed counter
      # HELP vsm_variety_generated The amount of variety generated by each subsystem  
      # TYPE vsm_variety_generated counter
      # HELP vsm_algedonic_pain Pain signals intensity (0-1)
      # TYPE vsm_algedonic_pain gauge
      # HELP vsm_algedonic_pleasure Pleasure signals intensity (0-1)
      # TYPE vsm_algedonic_pleasure gauge
      # HELP vsm_subsystem_health Health percentage of each VSM subsystem
      # TYPE vsm_subsystem_health gauge
      # HELP vsm_cybernetic_loop_latency Latency of cybernetic feedback loops in milliseconds
      # TYPE vsm_cybernetic_loop_latency histogram
      # HELP metrics_cardinality_total Current number of unique metric series
      # TYPE metrics_cardinality_total gauge
      
      """
      
      # Add meta-metrics about the metrics system
      meta_metrics = generate_meta_metrics(metrics_text, cardinality)
      
      # Combine all parts
      header <> type_annotations <> metrics_text <> "\n" <> meta_metrics
    end
  end

  # Count unique metric series for cardinality tracking
  defp count_metric_cardinality(metrics_text) do
    metrics_text
    |> String.split("\n")
    |> Enum.reject(&(String.starts_with?(&1, "#") || String.trim(&1) == ""))
    |> Enum.map(&extract_metric_name/1)
    |> Enum.reject(&is_nil/1)
    |> Enum.uniq()
    |> Enum.count()
  end
  
  # Extract metric name from a metric line
  defp extract_metric_name(line) do
    # Match metric name with optional labels
    # Format: metric_name{labels} value or metric_name value
    case Regex.run(~r/^([a-zA-Z_][a-zA-Z0-9_:]*)(?:[\s{]|$)/, line) do
      [_, name] -> name
      _ -> nil
    end
  end

  # Generate meta-metrics about the metrics system itself
  defp generate_meta_metrics(metrics_text, cardinality) do
    size_bytes = byte_size(metrics_text)
    
    """
    # Meta-metrics for observability of the metrics system
    metrics_cardinality_total #{cardinality}
    metrics_response_size_bytes #{size_bytes}
    metrics_endpoint_up 1
    """
  end
  
  # Safely truncate metrics to stay under cardinality limit
  defp truncate_metrics_safely(metrics_text, limit) do
    metrics_text
    |> String.split("\n")
    |> Enum.take(limit)
    |> Enum.join("\n")
  end
end